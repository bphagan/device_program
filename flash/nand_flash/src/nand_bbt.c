/*
 *  drivers/mtd/nand_bbt.c
 *
 *  Overview:
 *   Bad block table support for the NAND driver
 *
 *  Copyright (C) 2004 Thomas Gleixner (tglx@linutronix.de)
 *
 * $Id: nand_bbt.c,v 1.36 2005/11/07 11:14:30 gleixner Exp $
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * Description:
 *
 * When nand_scan_bbt is called, then it tries to find the bad block table
 * depending on the options in the bbt descriptor(s). If a bbt is found
 * then the contents are read and the memory based bbt is created. If a
 * mirrored bbt is selected then the mirror is searched too and the
 * versions are compared. If the mirror has a greater version number
 * than the mirror bbt is used to build the memory based bbt.
 * If the tables are not versioned, then we "or" the bad block information.
 * If one of the bbt's is out of date or does not exist it is (re)created.
 * If no bbt exists at all then the device is scanned for factory marked
 * good / bad blocks and the bad block tables are created.
 *
 * For manufacturer created bbts like the one found on M-SYS DOC devices
 * the bbt is searched and read but never created
 *
 * The autogenerated bad block table is located in the last good blocks
 * of the device. The table is mirrored, so it can be updated eventually.
 * The table is marked in the oob area with an ident pattern and a version
 * number which indicates which of both tables is more up to date.
 *
 * The table uses 2 bits per block
 * 11b: 	block is good
 * 00b: 	block is factory marked bad
 * 01b, 10b: 	block is marked bad due to wear
 *
 * The memory bad block table uses the following scheme:
 * 00b:		block is good
 * 01b:		block is marked bad due to wear
 * 10b:		block is reserved (to protect the bbt area)
 * 11b:		block is factory marked bad
 *
 * Multichip devices like DOC store the bad block info per floor.
 *
 * Following assumptions are made:
 * - bbts start at a page boundary, if autolocated on a block boundary
 * - the space necessary for a bbt in FLASH does not exceed a block boundary
 *
 */

#include "type.h"
#include "flash_lib.h"
#include "string.h"
#include "stdlib.h"
#include "nand_flash.h"
#include "nfc_base.h"

/* The number of bits used per block in the bbt on the device */
#define NAND_BBT_NRBITS_MSK	0x0000000F
#define NAND_BBT_1BIT		0x00000001
#define NAND_BBT_2BIT		0x00000002
#define NAND_BBT_4BIT		0x00000004
#define NAND_BBT_8BIT		0x00000008
/* The bad block table is in the last good block of the device */
#define	NAND_BBT_LASTBLOCK	0x00000010
/* The bbt is at the given page, else we must scan for the bbt */
#define NAND_BBT_ABSPAGE	0x00000020
/* The bbt is at the given page, else we must scan for the bbt */
#define NAND_BBT_SEARCH		0x00000040
/* bbt is stored per chip on multichip devices */
#define NAND_BBT_PERCHIP	0x00000080
/* bbt has a version counter at offset veroffs */
#define NAND_BBT_VERSION	0x00000100
/* Create a bbt if none axists */
#define NAND_BBT_CREATE		0x00000200
/* Search good / bad pattern through all pages of a block */
#define NAND_BBT_SCANALLPAGES	0x00000400
/* Scan block empty during good / bad block scan */
#define NAND_BBT_SCANEMPTY	0x00000800
/* Write bbt if neccecary */
#define NAND_BBT_WRITE		0x00001000
/* Read and write back block contents when writing bbt */
#define NAND_BBT_SAVECONTENT	0x00002000
/* Search good / bad pattern on the first and the second page */
#define NAND_BBT_SCAN2NDPAGE	0x00004000

/* The maximum number of blocks to scan for a bbt */
#define NAND_BBT_SCAN_MAXBLOCKS	4
#define NAND_MAX_CHIPS		8

#define min(a, b)  (((a) < (b)) ? (a) : (b))

/**
 * struct nand_bbt_descr - bad block table descriptor
 * @options:	options for this descriptor
 * @pages:	the page(s) where we find the bbt, used with option BBT_ABSPAGE
 *		when bbt is searched, then we store the found bbts pages here.
 *		Its an array and supports up to 8 chips now
 * @offs:	offset of the pattern in the oob area of the page
 * @veroffs:	offset of the bbt version counter in the oob are of the page
 * @version:	version read from the bbt page during scan
 * @len:	length of the pattern, if 0 no pattern check is performed
 * @maxblocks:	maximum number of blocks to search for a bbt. This number of
 *		blocks is reserved at the end of the device where the tables are
 *		written.
 * @reserved_block_code: if non-0, this pattern denotes a reserved (rather than
 *              bad) block in the stored bbt
 * @pattern:	pattern to identify bad block table or factory marked good /
 *		bad blocks, can be NULL, if len = 0
 *
 * Descriptor for the bad block table marker and the descriptor for the
 * pattern which identifies good and bad blocks. The assumption is made
 * that the pattern and the version count are always located in the oob area
 * of the first block.
 */
struct nand_bbt_descr {
	int	options;
	int	pages[NAND_MAX_CHIPS];
	int	offs;
	int	veroffs;
	u8	version[NAND_MAX_CHIPS];
	int	len;
	int	maxblocks;
	int	reserved_block_code;
	u8	*pattern;
};

/* Generic flash bbt decriptors
*/
static u8 bbt_pattern[] = {'B', 'b', 't', '0' };
static u8 mirror_pattern[] = {'1', 't', 'b', 'B' };

static struct nand_bbt_descr bbt_main_descr = {
	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
		| NAND_BBT_2BIT | NAND_BBT_VERSION,
	.offs =	0,
	.len = 4,
	.veroffs = 4,
	.maxblocks = 4,
	.pattern = bbt_pattern
};

static struct nand_bbt_descr bbt_mirror_descr = {
	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
		| NAND_BBT_2BIT | NAND_BBT_VERSION,
	.offs =	0,
	.len = 4,
	.veroffs = 4,
	.maxblocks = 4,
	.pattern = mirror_pattern
};

/**
 * check_pattern - [GENERIC] check if a pattern is in the buffer
 * @buf:	the buffer to search
 * @len:	the length of buffer to search
 * @paglen:	the pagelength
 * @td:		search pattern descriptor
 *
 * Check for a pattern at the given place. Used to search bad block
 * tables and good / bad block identifiers.
 * If the SCAN_EMPTY option is set then check, if all bytes except the
 * pattern area contain 0xff
 *
*/
static int check_pattern(u8 *buf, int len, int paglen, struct nand_bbt_descr *td)
{
	int i, end = 0;
	u8 *p = buf;

	end = paglen + td->offs;
	if (td->options & NAND_BBT_SCANEMPTY) {
		for (i = 0; i < end; i++) {
			if (p[i] != 0xff)
				return -1;
		}
	}
	p += end;

	/* Compare the pattern */
	for (i = 0; i < td->len; i++) {
		if (p[i] != td->pattern[i])
			return -1;
	}

	if (td->options & NAND_BBT_SCANEMPTY) {
		p += td->len;
		end += td->len;
		for (i = end; i < len; i++) {
			if (*p++ != 0xff)
				return -1;
		}
	}
	return 0;
}

/**
 * read_bbt - [GENERIC] Read the bad block table starting from page
 * @nd:	    nand  device structure
 * @buf:	temporary buffer
 * @page:	the starting page
 * @num:	the number of bbt descriptors to read
 * @bits:	number of bits per block
 * @offs:	offset in the memory table
 * @reserved_block_code:	Pattern to identify reserved blocks
 *
 * Read the bad block table starting from page.
 *
 */
static int read_bbt(struct nand_device_info *nd, u8 *buf, int page, int num,
		    int bits, int offs, int reserved_block_code)
{
	int res, i, j, act = 0;
	u32 retlen, len, totlen;
	u64 from;
	u8 msk = (u8) ((1 << bits) - 1);

	totlen = (num * bits) >> 3;
	from = ((u64) page) * nd->page_size;

	while (totlen) {
		len = min(totlen, (u32) (nd->page_size * nd->ppb));

		res = nand_read((u32)from,(u32)buf,len,NULL);
		
		if (res < 0) {
			if (retlen != len) {
				return res;
			}
		}

		/* Analyse data */
		for (i = 0; i < len; i++) {
			u8 dat = buf[i];
			for (j = 0; j < 8; j += bits, act += 2) {
				u8 tmp = (dat >> j) & msk;
				if (tmp == msk)
					continue;
				if (reserved_block_code && (tmp == reserved_block_code)) {
					nd->bbt[offs + (act >> 3)] |= 0x2 << (act & 0x06);
					continue;
				}
				/* Leave it for now, if its matured we can move this
				 * message to nand_DEBUG_LEVEL0 */
				
				/* Factory marked bad or worn out ? */
				if (tmp == 0)
					nd->bbt[offs + (act >> 3)] |= 0x3 << (act & 0x06);
				else
					nd->bbt[offs + (act >> 3)] |= 0x1 << (act & 0x06);
			}
		}
		totlen -= len;
		from += len;
	}
	return 0;
}
/**
 * read_abs_bbt - [GENERIC] Read the bad block table starting at a given page
 * @nd:		nand device structure
 * @buf:	temporary buffer
 * @td:		descriptor for the bad block table
 * @chip:	read the table for a specific chip, -1 read all chips.
 *		Applies only if NAND_BBT_PERCHIP option is set
 *
 * Read the bad block table for all chips starting at a given page
 * We assume that the bbt bits are in consecutive order.
*/
static int read_abs_bbt(struct nand_device_info *nd, u8 *buf, struct nand_bbt_descr *td, int chip)
{
	int res = 0, i;
	int bits;

	bits = td->options & NAND_BBT_NRBITS_MSK;
	if (td->options & NAND_BBT_PERCHIP) {
		int offs = 0;
		for (i = 0; i < nd->num_chips; i++) {
			if (chip == -1 || chip == i)
				res = read_bbt (nd, buf, td->pages[i], nd->blk_count, bits, offs, td->reserved_block_code);
			if (res)
				return res;
			offs += (nd->blk_count >> 2);
		}
	} else {
		res = read_bbt (nd, buf, td->pages[0], nd->blk_count, bits, 0, td->reserved_block_code);
		if (res)
			return res;
	}
	return 0;
}
/*
 * Scan read raw data from flash
 */
static int scan_read_raw(struct nand_device_info *nd, u8 *buf, u64 offs,
			 u32 len)
{
	nand_read((u32)offs, (u32)buf, (u32)len, NULL);
	copy_spare(nd, (char *)&buf[len], 0, nd->oob_size, 1);
	return 0;
}

/*
 * Scan write data with oob to flash
 */
static int scan_write_bbt(struct nand_device_info *nd, u64 offs, u32 len,
			  u8 *buf, u8 *oob)
{
	/* write with user oob */
	copy_spare(nd, (char*)&buf[len], 0, nd->oob_size, 0);
	nand_write((u32)offs, (u32)buf, (u32)len, FILE_FORMAT_OPS, NULL);
	
	return 0;
}

/**
 * create_bbt - [GENERIC] Create a bad block table by scanning the device
 * @nd:		nand device structure
 * @buf:	temporary buffer
 * @bd:		descriptor for the good/bad block search pattern
 * @chip:	create the table for a specific chip, -1 read all chips.
 *		Applies only if NAND_BBT_PERCHIP option is set
 *
 * Create a bad block table by scanning the device
 * for the given good/bad block identify pattern
 */
static int create_bbt(struct nand_device_info *nd, u8 *buf,struct nand_bbt_descr *bd, int chip)
{
	int i, numblocks = 0;
	int startblock = 0;	
	
        if (chip == -1) {
                numblocks = (nd->blk_count * nd->num_chips) << 1;
                startblock = 0;
        } else {
                if (chip >= nd->num_chips) {
                        return -1;
                }
                numblocks = (nd->blk_count << 1);
                startblock = chip * numblocks;
                numblocks += startblock;
        }

	for (i = startblock; i < numblocks;) {
		int ret;

		ret = nand_block_is_good(i >> 1);
		
		if (ret < 0)
			return ret;

		if (!ret) {
			nd->bbt[i >> 3] |= 0x03 << (i & 0x6);
		}

		i += 2;
	}
	return 0;
}

/**
 * search_bbt - [GENERIC] scan the device for a specific bad block table
 * @nd:		nand device structure
 * @buf:	temporary buffer
 * @td:		descriptor for the bad block table
 *
 * Read the bad block table by searching for a given ident pattern.
 * Search is preformed either from the beginning up or from the end of
 * the device downwards. The search starts always at the start of a
 * block.
 * If the option NAND_BBT_PERCHIP is given, each chip is searched
 * for a bbt, which contains the bad block information of this chip.
 * This is necessary to provide support for certain DOC devices.
 *
 * The bbt ident pattern resides in the oob area of the first page
 * in a block.
 */
static int search_bbt(struct nand_device_info *nd, u8 *buf, struct nand_bbt_descr *td)
{
	int i, chips;
	int bits, startblock, block, dir;
	int scanlen = nd->page_size + nd->oob_size;
	int bbtblocks;

	/* Search direction top -> down ? */
	if (td->options & NAND_BBT_LASTBLOCK) {
		startblock = nd->blk_count * nd->num_chips - 1;
		dir = -1;
	} else {
		startblock = 0;
		dir = 1;
	}

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP) {
		chips = nd->num_chips;
		bbtblocks = nd->blk_count;
		startblock &= bbtblocks - 1;
	} else {
		chips = 1;
		bbtblocks = nd->blk_count * nd->num_chips;
	}

	/* Number of bits for each erase block in the bbt */
	bits = td->options & NAND_BBT_NRBITS_MSK;

	for (i = 0; i < chips; i++) {
		/* Reset version information */
		td->version[i] = 0;
		td->pages[i] = -1;
		/* Scan the maximum number of blocks */
		for (block = 0; block < td->maxblocks; block++) {

			int actblock = startblock + dir * block;
			u64 offs = actblock * nd->page_size * nd->ppb ;

			/* Read first page */
			scan_read_raw(nd, buf, offs, nd->page_size);
			if (!check_pattern(buf, scanlen, nd->page_size, td)) {
				td->pages[i] = actblock * nd->ppb ;
				if (td->options & NAND_BBT_VERSION) {
					td->version[i] = buf[nd->page_size + td->veroffs];
				}
				break;
			}
		}
		startblock += nd->blk_count;
	}

	return 0;
}

/**
 * search_read_bbts - [GENERIC] scan the device for bad block table(s)
 * @nd:		nand device structure
 * @buf:	temporary buffer
 * @td:		descriptor for the bad block table
 * @md:		descriptor for the bad block table mirror
 *
 * Search and read the bad block table(s)
*/
static int search_read_bbts(struct nand_device_info *nd, u8 * buf, struct nand_bbt_descr *td, struct nand_bbt_descr *md)
{
	/* Search the primary table */
	search_bbt(nd, buf, td);

	/* Search the mirror table */
	if (md)
		search_bbt(nd, buf, md);

	/* Force result check */
	return 1;
}

/**
 * write_bbt - [GENERIC] (Re)write the bad block table
 *
 * @nd:		nand device structure
 * @buf:	temporary buffer
 * @td:		descriptor for the bad block table
 * @md:		descriptor for the bad block table mirror
 * @chipsel:	selector for a specific chip, -1 for all
 *
 * (Re)write the bad block table
 *
*/
static int write_bbt(struct nand_device_info *nd, u8 *buf,
		     struct nand_bbt_descr *td, struct nand_bbt_descr *md,
		     int chipsel)
{
	int i, j, res, chip = 0;
	int bits, startblock, dir, page, offs, numblocks, sft, sftmsk;
	int nrchips, bbtoffs, ooboffs;
	u8 msk[4];
	u8 rcode = td->reserved_block_code;
	u32 len = 0;
	u64 to;

	if (!rcode)
		rcode = 0xff;
	/* Write bad block table per chip rather than per device ? */
	if (td->options & NAND_BBT_PERCHIP) {
		numblocks = nd->blk_count;
		/* Full device write or specific chip ? */
		if (chipsel == -1) {
			nrchips = nd->num_chips;
		} else {
			nrchips = chipsel + 1;
			chip = chipsel;
		}
	} else {
		numblocks = nd->blk_count * nd->num_chips;
		nrchips = 1;
	}
	
	/* Loop through the chips */
	for (; chip < nrchips; chip++) {

		/* There was already a version of the table, reuse the page
		 * This applies for absolute placement too, as we have the
		 * page nr. in td->pages.
		 */
		if (td->pages[chip] != -1) {
			page = td->pages[chip];
			goto write;
		}

		/* Automatic placement of the bad block table */
		/* Search direction top -> down ? */
		if (td->options & NAND_BBT_LASTBLOCK) {
			startblock = numblocks * (chip + 1) - 1;
			dir = -1;
		} else {
			startblock = chip * numblocks;
			dir = 1;
		}

		for (i = 0; i < td->maxblocks; i++) {
			int block = startblock + dir * i;
			/* Check, if the block is bad */
			switch ((nd->bbt[block >> 2] >>
				 (2 * (block & 0x03))) & 0x03) {
			case 0x01:
			case 0x03:
				continue;
			}
			page = block * nd->ppb;
			/* Check, if the block is used by the mirror table */
			if (!md || md->pages[chip] != page)
				goto write;
		}
		
		return -1;
	write:

		/* Set up shift count and masks for the flash table */
		bits = td->options & NAND_BBT_NRBITS_MSK;
		msk[2] = ~rcode;
		switch (bits) {
		case 1: sft = 3; sftmsk = 0x07; msk[0] = 0x00; msk[1] = 0x01;
			msk[3] = 0x01;
			break;
		case 2: sft = 2; sftmsk = 0x06; msk[0] = 0x00; msk[1] = 0x01;
			msk[3] = 0x03;
			break;
		case 4: sft = 1; sftmsk = 0x04; msk[0] = 0x00; msk[1] = 0x0C;
			msk[3] = 0x0f;
			break;
		case 8: sft = 0; sftmsk = 0x00; msk[0] = 0x00; msk[1] = 0x0F;
			msk[3] = 0xff;
			break;
		default: return -1;
		}

		bbtoffs = chip * (numblocks >> 2);

		to = ((u64) page) * nd->page_size;

		
		/* Calc length */
		len = (u32) (numblocks >> sft);
		/* Make it page aligned ! */
		len = (len + (nd->page_size - 1)) & ~(nd->page_size - 1);
		/* Preset the buffer with 0xff */
		memset(buf, 0xff, len + (len / nd->page_size)* nd->oob_size);
		offs = 0;
		ooboffs = len;
		/* Pattern is located in oob area of first page */
		memcpy(&buf[ooboffs + td->offs], td->pattern, td->len);
		
		if (td->options & NAND_BBT_VERSION)
			buf[ooboffs + td->veroffs] = td->version[chip];

		/* walk through the memory table */
		for (i = 0; i < numblocks;) {
			u8 dat;
			dat = nd->bbt[bbtoffs + (i >> 2)];
			for (j = 0; j < 4; j++, i++) {
				int sftcnt = (i << (3 - sft)) & sftmsk;
				/* Do not store the reserved bbt blocks ! */
				buf[offs + (i >> sft)] &=
					~(msk[dat & 0x03] << sftcnt);
				dat >>= 2;
			}
		}

		res = nand_erase_block(page / nd->ppb);
		
		if (res < 0)
			goto outerr;
					
		res = scan_write_bbt(nd, to, len, buf, &buf[len]);
		
		if (res < 0)
			goto outerr;

		/* Mark it as used */
		td->pages[chip] = page;
	}
	return 0;

 outerr:
	return res;
}

/**
 * check_create - [GENERIC] create and write bbt(s) if necessary
 * @nd:		nand device structure
 * @buf:	temporary buffer
 * @bd:		descriptor for the good/bad block search pattern
 *
 * The function checks the results of the previous call to read_bbt
 * and creates / updates the bbt(s) if necessary
 * Creation is necessary if no bbt was found for the chip/device
 * Update is necessary if one of the tables is missing or the
 * version nr. of one table is less than the other
*/
static int check_create(struct nand_device_info *nd, u8 *buf, struct nand_bbt_descr *bd)
{
	int i, chips, writeops, chipsel, res;
	struct nand_bbt_descr *td = &bbt_main_descr;
	struct nand_bbt_descr *md = &bbt_mirror_descr;
	struct nand_bbt_descr *rd, *rd2;

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP)
		chips = nd->num_chips;
	else
		chips = 1;

	for (i = 0; i < chips; i++) {
		writeops = 0;
		rd = NULL;
		rd2 = NULL;
		/* Per chip or per device ? */
		chipsel = (td->options & NAND_BBT_PERCHIP) ? i : -1;
		/* Mirrored table avilable ? */
		if (md) {
			if (td->pages[i] == -1 && md->pages[i] == -1) {
				writeops = 0x03;
				goto create;
			}

			if (td->pages[i] == -1) {
				rd = md;
				td->version[i] = md->version[i];
				writeops = 1;
				goto writecheck;
			}

			if (md->pages[i] == -1) {
				rd = td;
				md->version[i] = td->version[i];
				writeops = 2;
				goto writecheck;
			}

			if (td->version[i] == md->version[i]) {
				rd = td;
				if (!(td->options & NAND_BBT_VERSION))
					rd2 = md;
				goto writecheck;
			}

			if (((u8) (td->version[i] - md->version[i])) > 0) {
				rd = td;
				md->version[i] = td->version[i];
				writeops = 2;
			} else {
				rd = md;
				td->version[i] = md->version[i];
				writeops = 1;
			}

			goto writecheck;

		} else {
			if (td->pages[i] == -1) {
				writeops = 0x01;
				goto create;
			}
			rd = td;
			goto writecheck;
		}
	create:
		
		/* Create the bad block table by scanning the device ? */
		if (!(td->options & NAND_BBT_CREATE))
			continue;

		/* Create the table in memory by scanning the chip(s) */
		create_bbt(nd, buf, bd, chipsel);

		td->version[i] = 1;
		if (md)
			md->version[i] = 1;	
	writecheck:
		/* read back first ? */
		if (rd)
			read_abs_bbt(nd, buf, rd, chipsel);
		/* If they weren't versioned, read both. */
		if (rd2)
			read_abs_bbt(nd, buf, rd2, chipsel);

		/* Write the bad block table to the device ? */
		if ((writeops & 0x01) && (td->options & NAND_BBT_WRITE)) {
			res = write_bbt(nd, buf, td, md, chipsel);
			if (res < 0)
				return res;
		}

		/* Write the mirror bad block table to the device ? */
		if ((writeops & 0x02) && md && (md->options & NAND_BBT_WRITE)) {
			res = write_bbt(nd, buf, md, td, chipsel);
			if (res < 0)
				return res;
		}
	}
	return 0;
}

/**
 * mark_bbt_regions - [GENERIC] mark the bad block table regions
 * @nd:		nand device structure
 * @td:		bad block table descriptor
 *
 * The bad block table regions are marked as "bad" to prevent
 * accidental erasures / writes. The regions are identified by
 * the mark 0x02.
*/
static void mark_bbt_region(struct nand_device_info *nd, struct nand_bbt_descr *td)
{
	int i, j, chips, block, nrblocks, update;
	u8 oldval, newval;

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP) {
		chips = nd->num_chips;
		nrblocks = nd->blk_count;

	} else {
		chips = 1;
		nrblocks = nd->blk_count * nd->num_chips;
	}

	for (i = 0; i < chips; i++) {
		if ((td->options & NAND_BBT_ABSPAGE) ||
		    !(td->options & NAND_BBT_WRITE)) {
			if (td->pages[i] == -1)
				continue;
			block = td->pages[i] / nd->ppb;
			block <<= 1;
			oldval = nd->bbt[(block >> 3)];
			newval = oldval | (0x2 << (block & 0x06));
			nd->bbt[(block >> 3)] = newval;
			if ((oldval != newval) && td->reserved_block_code)
				nand_update_bbt(nd, td->pages[i] * nd->page_size);
			continue;
		}
		update = 0;
		if (td->options & NAND_BBT_LASTBLOCK)
			block = ((i + 1) * nrblocks) - td->maxblocks;
		else
			block = i * nrblocks;
		block <<= 1;
		for (j = 0; j < td->maxblocks; j++) {
			oldval = nd->bbt[(block >> 3)];
			newval = oldval | (0x2 << (block & 0x06));
			nd->bbt[(block >> 3)] = newval;
			if (oldval != newval)
				update = 1;
			block += 2;
		}
		/* If we want reserved blocks to be recorded to flash, and some
		   new ones have been marked, then we need to update the stored
		   bbts.  This should only happen once. */
		if (update && td->reserved_block_code)
			nand_update_bbt(nd, ((block - 2) >> 1) * nd->page_size * nd->ppb);
	}
}

/**
 * nand_scan_bbt - [NAND Interface] scan, find, read and maybe create bad block table(s)
 * @nd:		nand device structure
 * @bd:		descriptor for the good/bad block search pattern
 *
 * The function checks, if a bad block table(s) is/are already
 * available. If not it scans the device for manufacturer
 * marked good / bad blocks and writes the bad block table(s) to
 * the selected place.
 *
 * The bad block table memory is allocated here. It must be freed
 * by calling the nand_free_bbt function.
 *
*/
int nand_scan_bbt(struct nand_device_info *nd)
{
	
	int len, res = 0;
	u8 *buf;
	struct nand_bbt_descr *td = &bbt_main_descr;
	struct nand_bbt_descr *md = &bbt_mirror_descr;
		
	/* Allocate a temporary buffer for one eraseblock incl. oob */
	len = (nd->page_size * nd->ppb);
	len += (nd->ppb) * nd->oob_size;
	buf = malloc(len);
	if (!buf) {
		return -1;
	}
	/* Search the bad block table using a pattern in oob */
	res = search_read_bbts(nd, buf, td, md);
	
	if (res)
		res = check_create(nd, buf, 0); //jason
	
	/* Prevent the bbt regions from erasing / writing */
	mark_bbt_region(nd, td);
	if (md)
		mark_bbt_region(nd, md);

	free(buf);
	return res;
}


 /* nand_update_bbt - [NAND Interface] update bad block table(s)
 * @nd:		nand device structure
 * @offs:	the offset of the newly marked block
 *
 * The function updates the bad block table(s)
*/
int nand_update_bbt(struct nand_device_info *nd, u64 offs)
{
	int len, res = 0, writeops = 0;
	int chip, chipsel;
	u8 *buf;
	struct nand_bbt_descr *td = &bbt_main_descr;
	struct nand_bbt_descr *md = &bbt_mirror_descr;

	if (!nd->bbt || !td)
		return -1;

	len = (nd->blk_count >> 2);
	/* Allocate a temporary buffer for one eraseblock incl. oob */
	len = nd->page_size * nd->ppb;
	len += nd->ppb * nd->oob_size;
	buf = malloc(len);
	if (!buf) {
		return -2;
	}

	writeops = md != NULL ? 0x03 : 0x01;

	/* Do we have a bbt per chip ? */
	if (td->options & NAND_BBT_PERCHIP) {
		chip = 0;
		chipsel = chip;
	} else {
		chip = 0;
		chipsel = -1;
	}

	td->version[chip]++;
	if (md)
		md->version[chip]++;

	/* Write the bad block table to the device ? */
	if ((writeops & 0x01) && (td->options & NAND_BBT_WRITE)) {
		res = write_bbt(nd, buf, td, md, chipsel);
		if (res < 0)
			goto out;
	}
	/* Write the mirror bad block table to the device ? */
	if ((writeops & 0x02) && md && (md->options & NAND_BBT_WRITE)) {
		res = write_bbt(nd, buf, md, td, chipsel);
	}

 out:
	free(buf);
	return res;
}


/**
 * nand_isbad_bbt - [NAND Interface] Check if a block is bad
 * @nd:	nand device structure
 * @nrblk:	offset in the device
 * @allowbbt:	allow access to bad block table region
 *
*/
u8 nand_isbad_bbt(struct nand_device_info *nd, u32 nrblk, int allowbbt)
{

	int block;
	u8 res;

	/* Get block number * 2 */
	block = nrblk << 1;
	res = (nd->bbt[block >> 3] >> (block & 0x06)) & 0x03;


	switch ((int)res) {
	case 0x00:
		return 0;
	case 0x01:
		return 1;
	case 0x02:
		return allowbbt ? 0 : 1;
	}
	return 1;
}

/**
 * nand_default_block_markbad - [DEFAULT] mark a block bad
 * @nd:		nand device structure
 * @nrblk:	offset from device start
 *
 * This is the default implementation, which can be overridden by
 * a hardware specific driver.
*/
int nand_bbt_markbad(struct nand_device_info *nd, u32 nrblk)
{
	int ret;
	
	nd->bbt[nrblk >> 2] |= 0x01 << ((nrblk & 0x03) << 1);
	
	ret = nand_update_bbt(nd, nrblk * nd->page_size * nd->ppb);
	
	return ret;
}
